package leetcode

/*
解法: 分治 快速幂 + 迭代
由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。
我们还是以 x^77 作为例子：
可以发现：
	x^38 → x^77 中额外乘的 x 在 x^77 中贡献了 x；
	x^9  → x^19 中额外乘的 x 在之后被平方了 2 次，因此在 x^77 中贡献了 x^(2^2) = x^4
	x^4 → x^9 中额外乘的 x 在之后被平方了 3 次，因此在 x^77 中贡献了 x^(2^3) = x^8
	最初的 x 在之后被平方了 6 次，因此在 x^77 中贡献了 x^(2^6) = x^(64)
我们把这些贡献相乘，x * x^4 * x^8 * x^64 恰好等于 x^77
而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 x 在之后都会被平方若干次。
而这些指数 1，4，8 和 64，恰好就对应了 77 的二进制表示 1001101 中的每个 1

因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 n 的二进制拆分为
n = 2^i0 + 2^i1 + ... + 2^ik
那么 x^n = x^(2^i0) * x^(2^i1) * ... * x^(2^ik)
这样以来，我们从 x 开始不断地进行平方，得到 x^2, x^4, x^8, x^16,
如果 n 的第 k 个（从右往左，从 0 开始计数）二进制位为 1，那么我们就将对应的贡献 x^(2^k) 计入答案。
​


结果: 执行用时 :0 ms 内存消耗 :2 MB
*/


func referenceMyPow(x float64, n int) float64 {
	if n >= 0 {
		return referenceQuickMul(x, n)
	}
	return 1.0 / referenceQuickMul(x, -n)
}

func referenceQuickMul(x float64, N int) float64 {
	ans := 1.0
	// 贡献的初始值为 x
	xContribute := x
	// 在对 N 进行二进制拆分的同时计算答案
	for N > 0 {
		if N % 2 == 1 {
			// 如果 N 二进制表示的最低位为 1，那么需要计入贡献
			ans *= xContribute
		}
		// 将贡献不断地平方
		xContribute *= xContribute
		// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
		N /= 2
	}
	return ans
}